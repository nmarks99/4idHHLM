# Select stripe
record(mbbo, "$(P)stripe")
{
    field(PINI, 1)
    field(ZRST, "Rh") # +11mm
    field(ONST, "Si") #   0mm
    field(TWST, "Pt") # -11mm
    field(FLNK, "$(P)stripe_fanout.PROC")
}

# determine which stripe from Y readback
# FIX: currently between stripes is considered Si
record(calcout, "$(P)current_stripe_calc")
{
    field(INPA, "$(P)$(Y).RBV CP")
    field(CALC, "(A>=6 && A<=16) ? 0 : (A>=-5 && A<=5) ? 1 : (A>=-16 && A<=-6) ? 2 : 1")
}

record(ai, "$(P)Ecritical")
{
    field(DESC, "Ecrit (keV) for selected stripe")
}

record(ai, "$(P)alpha")
{
    field(DESC, "Glancing angle")
    field(PREC, 4)
}

record(ai, "$(P)beam_offset")
{
    field(DESC, "Beam offset")
    field(PREC, 4)
}

record(fanout, "$(P)stripe_fanout")
{
    field(LNK0, "$(P)Y_calc")
    field(LNK1, "$(P)Ec_calc")
    field(LNK2, "$(P)alpha_calc")
    field(LNK3, "$(P)beam_offset_calc")
}

record(calcout, "$(P)alpha_calc")
{
    field(INPA, "$(P)$(X1).RBV CP")
    field(INPB, "$(P)$(X2).RBV CP")
    field(CALC, "R2D*ATAN(D2R*(A-B)/670.0)") # atan((X1-X2)/d)
    field(OUT, "$(P)alpha PP")
}

record(calcout, "$(P)beam_offset_calc")
{
    field(INPA, "$(P)alpha.VAL CP")
    field(CALC, "0.670*SIN(A*D2R)+2")
    field(OUT, "$(P)beam_offset PP")
}

# Sets Y motor position according to selected stripe 
record(calcout, "$(P)Y_calc")
{
    field(INPA, "$(P)stripe.VAL")
    field(CALC, "(A == 0) ? 11 : (A == 1) ? 0 : (A == 2) ? -11 : 0")
    field(OUT, "$(P)$(Y).VAL CA")
}


# Sets critical energy $(P)Ecritical according to selected stripe
record(calcout, "$(P)Ec_calc")
{
    field(INPA, "$(P)stripe.VAL")
    field(CALC, "(A == 0) ? 21 : (A == 1) ? 10 : (A == 2) ? 27 : 0")
    field(OUT, "$(P)Ecritical PP")
}

record(calcout, "$(P)coarsePitchC1_calc")
{
    field(DESC, "C1 for coarsePitch pseudoMotor")
    field(PINI, 0)
    field(CALC, "1000.0/670.0")
    field(OUT, "$(P)mir:coarsePitchC1 PP")
}

record(ao, "$(P)RoCReq")
{
    field(FLNK,"$(P)GetTargetCounts.PROC")
    field(DRVH, "16.0")
    field(DRVH, "-16.0")
    field(PREC, 2)
}

record(ai, "$(P)BenderTargetRoC")
{
    field(DESC, "Nearest achievable RoC to RoCReq")
    field(PREC, 2)
}

record(calcout, "$(P)SetBenderTargetCounts")
{
    field(INPA, "$(P)GetTargetCounts.VAL")
    field(CALC, "A")
    field(OUT, "$(P)mir:curvature PP")
}

# current estimated radius of curvature based on interpolated data
record(ai, "$(P)EstimatedRoC")
{
    field(SCAN, "Passive")
    field(INP, "$(P)GetEstimatedRoC.VAL")
    field(PREC, 2)
}

##
## Subroutines are defined in 4idHHLM/4idHHLMApp/src/subs.c
##
# Loads the interpolated CSV data from iocBoot/ioc4idHHLM/bender_data/
# into two arrays in code. Only runs once at IOC init
record(sub, "$(P)BenderLookupInit")
{
    field(SNAM, "bender_lookup_init")
    field(PINI, 1)
}

# looks up encoder counts which should yield RoC
# closest to the requested RoC and stores the counts
# in the VAL field.
record(sub, "$(P)GetTargetCounts")
{
    field(INPA, "$(P)RoCReq.VAL")
    field(SNAM, "lookup_roc")
    field(FLNK, "$(P)SetBenderTargetCounts.PROC")
}

# looks up the radius of curvature that is closest to
# cooresponding to the current encoder counts and stores
# the RoC in the VAL field
record(sub, "$(P)GetEstimatedRoC")
{
    field(SCAN, "Passive")
    field(INPA, "$(P)mir:curvature.RBV CP")
    field(SNAM, "lookup_counts")
    field(FLNK, "$(P)EstimatedRoC.PROC")
}

