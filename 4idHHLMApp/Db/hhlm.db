# Commands Y motor to the desired stripe
record(mbbo, "$(P)stripe")
{
    field(ZRST, "Rh") # +11mm
    field(ONST, "Si") #   0mm
    field(TWST, "Pt") # -11mm
    field(VAL, 1)
    field(FLNK, "$(P)stripe_fanout.PROC")
}

record(ao, "$(P)RhPosition") {
    field(DESC, "Position of center of Rh stripe")
    field(VAL, "11")
    field(PREC, 3)
}

record(ao, "$(P)SiPosition") {
    field(DESC, "Position of center of Si stripe")
    field(VAL, "0")
    field(PREC, 3)
}

record(ao, "$(P)PtPosition") {
    field(DESC, "Position of center of Pt stripe")
    field(VAL, "-11")
    field(PREC, 3)
}

# determine which stripe from Y readback
# currently "between" stripes is considered Si
record(calcout, "$(P)current_stripe_calc")
{
    field(INPA, "$(P)$(Y).RBV CP")
    field(INPB, "$(P)RhPosition.VAL")
    field(INPC, "$(P)SiPosition.VAL")
    field(INPD, "$(P)PtPosition.VAL")
    field(CALC, "(ABS(A - B) <= 5) ? 0 : (ABS(A - C) <= 5) ? 1 : (ABS(A - D) <= 5) ? 2 : 3")
    field(OUT, "$(P)CurrentStripe PP")
    field(PINI, 1)
}

# The currently selected stripe
record(mbbo, "$(P)CurrentStripe") {
    field(ZRST, "Rh") # +11mm
    field(ONST, "Si") #   0mm
    field(TWST, "Pt") # -11mm
    field(THST, "None")
}

record(ai, "$(P)Ecritical")
{
    field(DESC, "Ecrit (keV) for selected stripe")
}

record(ai, "$(P)alpha")
{
    field(DESC, "Glancing angle")
    field(PREC, 4)
}

record(ai, "$(P)beam_offset")
{
    field(DESC, "Beam offset")
    field(PREC, 4)
}

record(fanout, "$(P)stripe_fanout")
{
    field(LNK0, "$(P)Y_calc")
    field(LNK1, "$(P)Ec_calc")
    field(LNK2, "$(P)alpha_calc")
    field(LNK3, "$(P)beam_offset_calc")
}

record(calcout, "$(P)alpha_calc")
{
    field(INPA, "$(P)$(X1).RBV CP")
    field(INPB, "$(P)$(X2).RBV CP")
    field(CALC, "R2D*ATAN(D2R*(A-B)/670.0)") # atan((X1-X2)/d)
    field(OUT, "$(P)alpha PP")
}

record(calcout, "$(P)beam_offset_calc")
{
    field(INPA, "$(P)alpha.VAL CP")
    field(CALC, "0.670*SIN(A*D2R)+2")
    field(OUT, "$(P)beam_offset PP")
}

# Sets Y motor position according to selected stripe 
record(calcout, "$(P)Y_calc")
{
    field(INPA, "$(P)stripe.VAL")
    field(INPB, "$(P)RhPosition.VAL")
    field(INPC, "$(P)SiPosition.VAL")
    field(INPD, "$(P)PtPosition.VAL")
    field(CALC, "(A == 0) ? B : (A == 1) ? C : (A == 2) ? D : 0")
    field(OUT, "$(P)$(Y).VAL CA")
}

# Sets critical energy $(P)Ecritical according to selected stripe
record(calcout, "$(P)Ec_calc")
{
    field(INPA, "$(P)stripe.VAL")
    field(CALC, "(A == 0) ? 21 : (A == 1) ? 10 : (A == 2) ? 27 : 0")
    field(OUT, "$(P)Ecritical PP")
}

record(ao, "$(P)RoCReq")
{
    field(FLNK,"$(P)GetTargetCounts.PROC")
    # field(DRVH, "16.0")
    # field(DRVH, "-16.0")
    field(PREC, 2)
}

record(ai, "$(P)BenderTargetRoC")
{
    field(DESC, "Nearest achievable RoC to RoCReq")
    field(PREC, 2)
}

record(calcout, "$(P)SetBenderTargetCounts")
{
    field(INPA, "$(P)GetTargetCounts.VAL")
    field(CALC, "A")
    field(OUT, "$(P)$(MIR_CURV) PP")
}

# current estimated radius of curvature based on interpolated data
record(ai, "$(P)EstimatedRoC")
{
    field(SCAN, "Passive")
    field(INP, "$(P)GetEstimatedRoC.VAL")
    field(PREC, 2)
}

##
## Subroutines are defined in 4idHHLM/4idHHLMApp/src/subs.c
##
# Loads the interpolated CSV data from iocBoot/ioc4idHHLM/bender_data/
# into two arrays in code. Only runs once at IOC init
record(sub, "$(P)BenderLookupInit")
{
    field(SNAM, "bender_lookup_init")
    field(PINI, 1)
}

# looks up encoder counts which should yield RoC
# closest to the requested RoC and stores the counts
# in the VAL field.
record(sub, "$(P)GetTargetCounts")
{
    field(INPA, "$(P)RoCReq.VAL")
    field(SNAM, "lookup_roc")
    field(FLNK, "$(P)SetBenderTargetCounts.PROC")
}

# looks up the radius of curvature that is closest to
# cooresponding to the current encoder counts and stores
# the RoC in the VAL field
record(sub, "$(P)GetEstimatedRoC")
{
    field(SCAN, "Passive")
    field(INPA, "$(P)$(MIR_CURV).RBV CP")
    field(SNAM, "lookup_counts")
    field(FLNK, "$(P)EstimatedRoC.PROC")
}

